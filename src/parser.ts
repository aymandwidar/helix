/**
 * Helix Parser - Parses .helix blueprint files into structured AST
 */

export interface HelixField {
    name: string;
    type: string;
    constraints?: string[];
}

export interface HelixStrand {
    name: string;
    fields: HelixField[];
    strategies: HelixStrategy[];
}

export interface HelixStrategy {
    name: string;
    action: string;
    condition?: string;
}

export interface HelixView {
    name: string;
    properties: Record<string, string>;
}

export interface HelixAST {
    strands: HelixStrand[];
    views: HelixView[];
    strategies: HelixStrategy[];
}

/**
 * Parse a .helix file content into an AST
 */
export function parseHelix(content: string): HelixAST {
    const ast: HelixAST = {
        strands: [],
        views: [],
        strategies: [],
    };

    // Remove comments
    const cleanContent = content
        .split('\n')
        .map(line => line.replace(/\/\/.*$/, '').trim())
        .join('\n');

    // Parse strands
    const strandRegex = /strand\s+(\w+)\s*\{([^}]+)\}/g;
    let match;

    while ((match = strandRegex.exec(cleanContent)) !== null) {
        const strandName = match[1];
        const strandBody = match[2];

        const strand: HelixStrand = {
            name: strandName,
            fields: [],
            strategies: [],
        };

        // Parse fields
        const fieldRegex = /field\s+(\w+)\s*:\s*([^\n]+)/g;
        let fieldMatch;
        while ((fieldMatch = fieldRegex.exec(strandBody)) !== null) {
            const fieldName = fieldMatch[1];
            const fieldType = fieldMatch[2].trim();

            strand.fields.push({
                name: fieldName,
                type: parseFieldType(fieldType),
            });
        }

        // Parse strategies within strand
        const strategyRegex = /strategy\s+(\w+)\s*:\s*([^\n]+)/g;
        let stratMatch;
        while ((stratMatch = strategyRegex.exec(strandBody)) !== null) {
            strand.strategies.push({
                name: stratMatch[1],
                action: stratMatch[2].trim(),
            });
        }

        ast.strands.push(strand);
    }

    // Parse views
    const viewRegex = /view\s+(\w+)\s*\{([^}]+)\}/g;
    while ((match = viewRegex.exec(cleanContent)) !== null) {
        const viewName = match[1];
        const viewBody = match[2];

        const view: HelixView = {
            name: viewName,
            properties: {},
        };

        // Parse view properties
        const propRegex = /(\w+)\s*:\s*([^\n]+)/g;
        let propMatch;
        while ((propMatch = propRegex.exec(viewBody)) !== null) {
            view.properties[propMatch[1]] = propMatch[2].trim();
        }

        ast.views.push(view);
    }

    // Parse top-level strategies
    const topStrategyRegex = /^strategy\s+(\w+)\s*:\s*(.+)$/gm;
    while ((match = topStrategyRegex.exec(cleanContent)) !== null) {
        ast.strategies.push({
            name: match[1],
            action: match[2].trim(),
        });
    }

    return ast;
}

/**
 * Convert Helix types to Prisma types
 */
export function toPrismaType(helixType: string): string {
    const typeMap: Record<string, string> = {
        'String': 'String',
        'Int': 'Int',
        'Float': 'Float',
        'Boolean': 'Boolean',
        'DateTime': 'DateTime',
        'Date': 'DateTime',
    };

    // Handle List types
    if (helixType.startsWith('List<')) {
        return helixType; // Will need relation handling
    }

    // Handle Enum types
    if (helixType.startsWith('Enum(')) {
        return 'String'; // Simplified - could generate actual enums
    }

    return typeMap[helixType] || 'String';
}

/**
 * Parse field type and extract base type
 */
function parseFieldType(typeStr: string): string {
    // Remove constraints like (Limit: 3)
    const baseType = typeStr.replace(/\([^)]*\)/g, '').trim();
    return baseType;
}

/**
 * Generate Prisma schema from AST
 */
export function generatePrismaSchema(ast: HelixAST): string {
    let schema = `// Generated by Helix v3.0
// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

`;

    for (const strand of ast.strands) {
        schema += `model ${strand.name} {\n`;
        schema += `  id        String   @id @default(cuid())\n`;
        schema += `  createdAt DateTime @default(now())\n`;
        schema += `  updatedAt DateTime @updatedAt\n`;

        for (const field of strand.fields) {
            const prismaType = toPrismaType(field.type);
            const isOptional = field.type.includes('?') ? '?' : '';
            const defaultValue = getDefaultValue(field.type);

            schema += `  ${field.name} ${prismaType}${isOptional}${defaultValue}\n`;
        }

        schema += `}\n\n`;
    }

    return schema;
}

function getDefaultValue(type: string): string {
    if (type === 'Boolean') return ' @default(false)';
    return '';
}

/**
 * Generate API route handler from strand
 */
export function generateAPIRoute(strand: HelixStrand): string {
    const modelName = strand.name;
    const lowerName = modelName.toLowerCase();

    return `// Generated by Helix v3.0
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

// GET all ${modelName}s
export async function GET() {
  try {
    const items = await prisma.${lowerName}.findMany({
      orderBy: { createdAt: 'desc' },
    });
    return NextResponse.json(items);
  } catch (error) {
    console.error('Error fetching ${modelName}s:', error);
    return NextResponse.json(
      { error: 'Failed to fetch ${modelName}s' },
      { status: 500 }
    );
  }
}

// POST create new ${modelName}
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const item = await prisma.${lowerName}.create({
      data: body,
    });
    return NextResponse.json(item, { status: 201 });
  } catch (error) {
    console.error('Error creating ${modelName}:', error);
    return NextResponse.json(
      { error: 'Failed to create ${modelName}' },
      { status: 500 }
    );
  }
}

// PUT update ${modelName}
export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    const { id, ...data } = body;
    
    const item = await prisma.${lowerName}.update({
      where: { id },
      data,
    });
    return NextResponse.json(item);
  } catch (error) {
    console.error('Error updating ${modelName}:', error);
    return NextResponse.json(
      { error: 'Failed to update ${modelName}' },
      { status: 500 }
    );
  }
}

// DELETE ${modelName}
export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    
    if (!id) {
      return NextResponse.json(
        { error: 'ID is required' },
        { status: 400 }
      );
    }
    
    await prisma.${lowerName}.delete({
      where: { id },
    });
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting ${modelName}:', error);
    return NextResponse.json(
      { error: 'Failed to delete ${modelName}' },
      { status: 500 }
    );
  }
}
`;
}

/**
 * Generate UI page component from view
 */
export function generateUIPage(view: HelixView, strand: HelixStrand): string {
    const viewName = view.name;
    const modelName = strand.name;
    const lowerName = modelName.toLowerCase();

    const fields = strand.fields.map(f => f.name);

    return `// Generated by Helix v3.0
'use client';

import { useState, useEffect } from 'react';
import { Plus, Trash2, Check, X } from 'lucide-react';

interface ${modelName} {
  id: string;
${strand.fields.map(f => `  ${f.name}: ${tsType(f.type)};`).join('\n')}
  createdAt: string;
}

export default function ${viewName}Page() {
  const [items, setItems] = useState<${modelName}[]>([]);
  const [loading, setLoading] = useState(true);
  const [newItem, setNewItem] = useState('');

  useEffect(() => {
    fetchItems();
  }, []);

  const fetchItems = async () => {
    try {
      const res = await fetch('/api/${lowerName}');
      const data = await res.json();
      setItems(data);
    } catch (error) {
      console.error('Failed to fetch items:', error);
    } finally {
      setLoading(false);
    }
  };

  const createItem = async () => {
    if (!newItem.trim()) return;
    
    try {
      const res = await fetch('/api/${lowerName}', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ${fields[0]}: newItem }),
      });
      
      if (res.ok) {
        setNewItem('');
        fetchItems();
      }
    } catch (error) {
      console.error('Failed to create item:', error);
    }
  };

  const deleteItem = async (id: string) => {
    try {
      await fetch(\`/api/${lowerName}?id=\${id}\`, { method: 'DELETE' });
      fetchItems();
    } catch (error) {
      console.error('Failed to delete item:', error);
    }
  };

  const toggleItem = async (item: ${modelName}) => {
    try {
      await fetch('/api/${lowerName}', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          id: item.id, 
          ${fields.find(f => f.includes('complet') || f.includes('done')) || 'is_completed'}: !item.${fields.find(f => f.includes('complet') || f.includes('done')) || 'is_completed'}
        }),
      });
      fetchItems();
    } catch (error) {
      console.error('Failed to update item:', error);
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-gray-900 to-black flex items-center justify-center">
        <div className="text-white text-xl">Loading...</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-gray-900 to-black p-8">
      <div className="max-w-2xl mx-auto">
        <h1 className="text-4xl font-bold text-white mb-8">${viewName}</h1>
        
        {/* Add New Item */}
        <div className="flex gap-4 mb-8">
          <input
            type="text"
            value={newItem}
            onChange={(e) => setNewItem(e.target.value)}
            onKeyDown={(e) => e.key === 'Enter' && createItem()}
            placeholder="Add new ${lowerName}..."
            className="flex-1 bg-white/10 border border-white/20 rounded-lg px-4 py-3 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-indigo-500"
          />
          <button
            onClick={createItem}
            className="bg-indigo-600 hover:bg-indigo-700 text-white px-6 py-3 rounded-lg flex items-center gap-2 transition-colors"
          >
            <Plus size={20} />
            Add
          </button>
        </div>

        {/* Items List */}
        <div className="space-y-3">
          {items.map((item) => (
            <div
              key={item.id}
              className="bg-white/10 backdrop-blur-lg rounded-lg p-4 flex items-center gap-4 group hover:bg-white/15 transition-colors"
            >
              <button
                onClick={() => toggleItem(item)}
                className={\`w-6 h-6 rounded-full border-2 flex items-center justify-center transition-colors \${
                  item.${fields.find(f => f.includes('complet') || f.includes('done')) || 'is_completed'}
                    ? 'bg-green-500 border-green-500'
                    : 'border-gray-400 hover:border-indigo-500'
                }\`}
              >
                {item.${fields.find(f => f.includes('complet') || f.includes('done')) || 'is_completed'} && <Check size={14} className="text-white" />}
              </button>
              
              <span className={\`flex-1 text-white \${item.${fields.find(f => f.includes('complet') || f.includes('done')) || 'is_completed'} ? 'line-through opacity-50' : ''}\`}>
                {item.${fields[0]}}
              </span>
              
              <button
                onClick={() => deleteItem(item.id)}
                className="opacity-0 group-hover:opacity-100 text-red-400 hover:text-red-300 transition-opacity"
              >
                <Trash2 size={18} />
              </button>
            </div>
          ))}
          
          {items.length === 0 && (
            <div className="text-center text-gray-400 py-12">
              No items yet. Add your first ${lowerName}!
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
`;
}

function tsType(helixType: string): string {
    const typeMap: Record<string, string> = {
        'String': 'string',
        'Int': 'number',
        'Float': 'number',
        'Boolean': 'boolean',
        'DateTime': 'string',
        'Date': 'string',
    };
    return typeMap[helixType] || 'string';
}
